// Copyright 2025, Evan Palmer
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

#pragma once

#include <cstdint>
#include <expected>
#include <functional>
#include <memory>
#include <string>

#include "rclcpp/rclcpp.hpp"

// auto-generated by generate_parameter_library
#include <whole_body_controllers/task_priority_ik_solver_parameters.hpp>

#include "ik_solver.hpp"

namespace ik_solvers
{

namespace hierarchy
{

/// Base class for constraints.
class Constraint
{
public:
  /// Create a new constraint given the current primal value, constraint value, task priority and feedback gain.
  Constraint(const Eigen::MatrixXd & primal, const Eigen::MatrixXd & constraint, int priority, double gain)
  : primal_(primal),
    constraint_(constraint),
    priority_(priority),
    gain_(gain){};

  /// Destructor.
  virtual ~Constraint() = default;

  /// Get the primal value for the constraint.
  [[nodiscard]] auto primal() const -> Eigen::MatrixXd { return primal_; };

  /// Get the Jacobian for the constraint.
  [[nodiscard]] auto jacobian() const -> Eigen::MatrixXd { return jacobian_; };

  /// Get the error between the primal and constraint value.
  [[nodiscard]] auto error() const -> Eigen::VectorXd { return error_; };

  /// Get the constraint priority.
  [[nodiscard]] auto priority() const -> int { return priority_; }

  /// Get the feedback gain.
  [[nodiscard]] auto gain() const -> double { return gain_; }

protected:
  Eigen::MatrixXd primal_;
  Eigen::MatrixXd constraint_;
  Eigen::MatrixXd jacobian_;
  Eigen::VectorXd error_;

  int priority_;
  double gain_;
};

/// Base class for scalar set constraints.
class SetConstraint : public Constraint
{
public:
  /// Create a new set constraint given the current primal value, constraint value, constraint bounds, tolerance,
  /// activation threshold, task priority,and gain.
  SetConstraint(double primal, double ub, double lb, double tol, double activation, int priority, double gain)
  : Constraint(Eigen::MatrixXd::Constant(1, 1, primal), Eigen::MatrixXd::Zero(1, 1), priority, gain),
    upper_limit_(ub),
    lower_limit_(lb),
    upper_safety_(ub - tol),
    lower_safety_(lb + tol),
    upper_threshold_(ub - tol - activation),
    lower_threshold_(lb + tol + activation)
  {
    // Set the constraint value based on whether or not the task is active
    // The constraint value is set to the safety value if the task is active
    if (primal < lower_threshold_ + std::numeric_limits<double>::epsilon()) {
      constraint_ = Eigen::MatrixXd::Constant(1, 1, lower_safety_);
    } else if (primal > upper_threshold_ - std::numeric_limits<double>::epsilon()) {
      constraint_ = Eigen::MatrixXd::Constant(1, 1, upper_safety_);
    } else {
      constraint_ = primal_;
    }
  };

  /// Check whether or not the constraint is active. Set constraints are only active when the current value is within
  /// the activation threshold for the task.
  [[nodiscard]] auto is_active() const -> bool
  {
    return primal_.value() < lower_threshold_ || primal_.value() > upper_threshold_;
  };

  /// Get the primal value for the constraint.
  [[nodiscard]] auto primal() const -> double { return primal_.value(); };

  /// Get the upper activation threshold for the constraint.
  [[nodiscard]] auto upper_threshold() const -> double { return upper_threshold_; }

  /// Get the lower activation threshold for the constraint.
  [[nodiscard]] auto lower_threshold() const -> double { return lower_threshold_; }

protected:
  double upper_limit_, lower_limit_;
  double upper_safety_, lower_safety_;
  double upper_threshold_, lower_threshold_;
};

/// Class used to manage an end effector pose constraint.
class PoseConstraint : public Constraint
{
public:
  /// Create a new end effector pose constraint given the system model and data, the primal and constraint poses, the
  /// name of the end effector frame, and the feedback gain.
  ///
  /// The constraint priority is set to 2 by default.
  PoseConstraint(
    const std::shared_ptr<pinocchio::Model> & model,
    const std::shared_ptr<pinocchio::Data> & data,
    const Eigen::Affine3d & primal,
    const Eigen::Affine3d & constraint,
    const std::string & frame,
    double gain,
    int priority = 2);
};

/// Class used to manage a joint constraint.
class JointConstraint : public SetConstraint
{
public:
  /// Create a new joint constraint given the system model and data, the current joint value, the upper and lower bounds
  /// for the joint, the tolerance, the activation threshold, the joint ID, and the feedback gain.
  ///
  /// The constraint priority is set to 1 by default.
  JointConstraint(
    const std::shared_ptr<pinocchio::Model> & model,
    double primal,
    double ub,
    double lb,
    double tol,
    double activation,
    const std::string & joint_name,
    double gain,
    int priority = 1);
};

/// Comparator used to sort constraints based on their priority.
/// If the priorities are equal, the constraints are sorted based on their memory address.
struct ConstraintCompare
{
  bool operator()(const std::shared_ptr<Constraint> & lhs, const std::shared_ptr<Constraint> & rhs) const
  {
    return lhs->priority() == rhs->priority() ? std::less<>{}(lhs, rhs) : lhs->priority() < rhs->priority();
  }
};

/// Type alias for a set of constraints.
using ConstraintSet = std::set<std::shared_ptr<Constraint>, ConstraintCompare>;

/// Class used to manage the task hierarchy.
class TaskHierarchy
{
public:
  /// Constructor.
  TaskHierarchy() = default;

  /// Insert a new constraint into the hierarchy. This will automatically sort the constraints based on their priority.
  ///
  /// For now, only equality constraints and high priority set constraints are supported.
  auto insert(const std::shared_ptr<Constraint> & constraint) -> void;

  /// Clear all constraints from the hierarchy.
  auto clear() -> void;

  /// Get the set of all active inequality constraints in the hierarchy.
  [[nodiscard]] auto set_constraints() const -> ConstraintSet;

  /// Get the set of all equality constraints in the hierarchy.
  [[nodiscard]] auto equality_constraints() const -> ConstraintSet;

  /// Get the set of all potential hierarchies for the active tasks.
  [[nodiscard]] auto hierarchies() const -> std::vector<ConstraintSet>;

private:
  ConstraintSet constraints_;
};

}  // namespace hierarchy

class TaskPriorityIKSolver : public IKSolver
{
public:
  TaskPriorityIKSolver() = default;

  virtual auto initialize(
    const std::shared_ptr<rclcpp_lifecycle::LifecycleNode> & node,
    const std::shared_ptr<pinocchio::Model> & model,
    const std::shared_ptr<pinocchio::Data> & data) -> void override;

protected:
  [[nodiscard]] auto solve_ik(const Eigen::Affine3d & goal, const Eigen::VectorXd & q)
    -> std::expected<Eigen::VectorXd, SolverError> override;

  /// Update the dynamic ROS 2 parameters.
  auto update_parameters() -> void;

  /// Configure the solver based on the current ROS 2 parameters.
  auto configure_parameters() -> void;

  hierarchy::TaskHierarchy hierarchy_;

  double damping_{1e-6};

  std::shared_ptr<task_priority_ik_solver::ParamListener> param_listener_;
  task_priority_ik_solver::Params params_;
};

}  // namespace ik_solvers
